*
* Replication File for Uhlig(2005), "What are the effects of monetary
* policy on output? Results from an agnostic identification procedure,"
* Journal of Monetary Economics, 52, pp 381-419.
*
* Penalty function approach.
*
open data uhligdata.xls
calendar(m) 1965
data(format=xls,org=columns) 1965:1 2003:12 $
   gdpc1 gdpdef cprindex totresns bognonbr fedfunds
*
set gdpc1    = log(gdpc1)*100.0
set gdpdef   = log(gdpdef)*100.0
set cprindex = log(cprindex)*100.0
set totresns = log(totresns)*100.0
set bognonbr = log(bognonbr)*100.0
*
system(model=varmodel)
variables gdpc1 gdpdef cprindex fedfunds bognonbr totresns
lags 1 to 12
end(system)
estimate(noprint)
*********************************************************************
source uhligfuncs.src
******************************************************
dec vect[strings] vl(6)
compute vl=||"real GDP","GDP price defl","Comm. Price Ind.",$
             "Fed Funds Rate","Nonborr. Reserv.","Total Reserves"||
*
* Get the scale factors to be used for impulse responses
*
dec vect scales(6)
dec real func
compute fill=0
dofor i = gdpc1 gdpdef cprindex fedfunds bognonbr totresns
   diff i / diff1
   stats(noprint) diff1
   compute fill=fill+1,scales(fill)=sqrt(%variance)
end dofor i
*
* nkeep is the desired number of draws from the posterior of the VAR
* nvar is the number of variables
* nstep is the number of IRF steps to compute
* KMAX is the "K" value for the number of steps constrained
*
compute nkeep=1000
compute nvar=6
compute nstep=60
compute KMIN=1
compute KMAX=5
declare vect[rect] goodresp(nkeep)
declare vector ik a(nvar)
*
* This uses the stereo projection of R^(n-1) to the unit sphere in R^n.
*
dec vect g(nvar-1)
compute g=%fill(nvar-1,1,1.0)
nonlin g
*
* This is the standard setup for MC integration of an OLS VAR
*
compute sxx    =%decomp(%xx)
compute svt    =%decomp(inv(%nobs*%sigma))
compute betaols=%modelgetcoeffs(varmodel)
compute ncoef  =%rows(sxx)
compute wishdof=%nobs-ncoef
*
infobox(action=define,progress,lower=1,upper=nkeep) $
  "Monte Carlo Integration"
*
* Plan for double the number of draws to allow for the ones which we
* reject.
*
compute accept=0
do draws=1,nkeep*2
   *
   * Make a draw from the posterior for the VAR and compute its impulse
   * responses.
   *
   compute sigmad  =%ranwisharti(svt,wishdof)
   compute swish   =%decomp(sigmad)
   compute betau   =%ranmvkron(swish,sxx)
   compute betadraw=betaols+betau
   compute %modelsetcoeffs(varmodel,betadraw)
   impulse(noprint,model=varmodel,decomp=swish,results=impulses,steps=nstep)
   *
   * Minimize the penalty function, starting from the last set of
   * minimizers.
   *
   find(noprint) min func
      compute a=%stereo(g)
      compute func=UhligPenalty(a,KMIN,KMAX+1,||+4,-3,-2,-5||)
   end find
   compute testfunc=func,testbeta=%beta
   *
   * Try the minimization again, starting from a standard set of values
   *
   compute g=%fill(nvar-1,1,1.0)
   find(noprint) min func
      compute a=%stereo(g)
      compute func=UhligPenalty(a,KMIN,KMAX+1,||+4,-3,-2,-5||)
   end find
   *
   * If the two estimates don't match, reject the draw. If they do, copy
   * out the impulse responses.
   *
   if abs(testfunc-func)>.001
      goto reject

   compute accept=accept+1
   dim goodresp(accept)(nstep,nvar)
   ewise goodresp(accept)(i,j)=ik=%xt(impulses,i)*a,ik(j)
   *
   * If we've hit out desired number of accepted draws, break
   *
   if accept>=nkeep
      break
   infobox(current=accept)
   :reject
end do draws
infobox(action=remove)
*
* Post-processing. Graph the mean of the responses along with the 16%
* and 84%-iles.
*
clear upper lower resp
*
spgraph(vfields=3,hfields=2,$
  hlabel="Figure 14. Impulse Responses with Penalty Function Approach")
do i=1,nvar
   compute minlower=maxupper=0.0
   smpl 1 accept
   do k=1,nstep
      set work = goodresp(t)(k,i)
      compute frac=%fractiles(work,||.16,.84||)
      compute lower(k)=frac(1)
      compute upper(k)=frac(2)
      compute resp(k)=%avg(work)
   end do k
   *
   smpl 1 nstep
   graph(ticks,number=0,picture="##.##",header="Impulse Responses for "+vl(i)) 3
   # resp
   # upper / 2
   # lower / 2
end do i
*
spgraph(done)

